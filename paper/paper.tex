\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in
\usepackage{ijcai21}
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algorithmic}
\urlstyle{same}

\usepackage{cleveref}

% \usepackage{showframe}

\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}

\usepackage{complexity}

\pdfinfo{
/TemplateVersion (IJCAI.2021.0)
}

\title{Solving Graph Homomorphism and Subgraph Isomorphism Problems Faster Through Clique Neighbourhood
Constraints}

\author{
Ciaran McCreesh$^1$
\and
Sonja Kraiczy$^2$
\affiliations
$^1$University of Glasgow\\
$^2$University of Oxford\\
\emails
ciaran.mccreesh@glasgow.ac.uk
}

\newcommand{\neighbourhood}{\operatorname{N}}
\newcommand{\vertexset}{\operatorname{V}}
\newcommand{\degree}{\operatorname{deg}}
\newcommand{\nds}{\operatorname{S}}

\begin{document}

\maketitle

\begin{abstract}
    We can find graph homomorphisms faster through clique constraints.
\end{abstract}

\section{Introduction}

A \emph{graph homomorphism} is a function between two graphs that maps adjacent vertices to adjacent
vertices. An injective graph homomorphism is more commonly known as a \emph{subgraph isomorphism},
whilst a \emph{locally injective homomorphism} is one which is injective when restricted to any
individual vertex and its neighbourhood \cite{DBLP:journals/csr/FialaK08}. Finding any of these three kinds of homomorphism between
two given graphs is \NP-complete.  The subgraph isomorphism problem arises in many practical
applications, including ??, and as such there has been a lot of research into finding algorithms
which perform well empirically. Most approaches are based either upon very fast but simple
backtracking algorithms,
\cite{DBLP:journals/pami/CordellaFSV04,DBLP:journals/bmcbi/BonniciGPSF13,DBLP:conf/gbrpr/CarlettiFSV17}
which often but not always perform well on very easy instances, or upon constraint programming
algorithms
\cite{DBLP:journals/constraints/ZampelliDS10,DBLP:journals/ai/Solnon10,DBLP:conf/cp/AudemardLMGP14,DBLP:conf/cp/McCreeshP15,DBLP:conf/cpaior/ArchibaldDHMP019},
which have higher startup costs but that perform vastly better on harder instances and much more
consistently on easy instances \cite{DBLP:journals/jair/McCreeshPST18,DBLP:conf/gbrpr/Solnon19}. The
current state of the art is the Glasgow Subgraph Solver \cite{DBLP:conf/gg/McCreeshP020}, which is a
dedicated constraint programming solver for subgraph-finding problems. Much of its performance comes
from inference strategies based upon degrees and neighbourhood degree sequences
\cite{DBLP:journals/constraints/ZampelliDS10}, counting paths between vertices
\cite{DBLP:conf/cp/AudemardLMGP14,DBLP:conf/cp/McCreeshP15}, and cardinality reasoning
\cite{DBLP:journals/ai/Solnon10}, which can be used to eliminate many infeasible candidate
assignments without search.

One might hope that this inference would also be helpful for other graph homomorphism problem
variants. Indeed, this paper proves that many, but not all, of these strategies are also valid in
the locally injective case, and that a weakened form of one other strategy is valid for all
homomorphisms. However, we also prove that \emph{none} of the other strategies are valid for finding
homomorphisms where there is no injectivity requirement. Finally, we introduce a new filtering
technique that is based upon finding the maximum clique in the neighbourhood of each vertex, and
prove that this technique is valid even in the general case. Although this new filtering technique
involves solving a large number of \NP-complete problems, we demonstrate that it is effective in
practice, particularly for the non-injective problem where filtering can solve instances ??many
hundreds of times faster in aggregate. This shows, for the first time, that modern constraint
programming techniques can be practical for less constrained graph homomorphism finding problems;
previous algorithmic approaches have focused instead upon worst-case computational bounds
\cite{DBLP:journals/csr/FialaK08,DBLP:journals/ipl/Rzazewski14,DBLP:journals/tcs/ChaplickFHPT15},
whose practical utility has yet to be demonstrated. The empirical effectiveness of our results is
especially important because many current applications use subgraph isomorphism solvers only because
they perform well using off the shelf solvers, rather than because they exactly match ideal domain
requirements ??cite.

\section{Background and Theory}

We begin by introducing notation and terminology, and by giving the theoretical results which
support our implementation.

\paragraph{Graphs.} Let $G$ and $H$ be graphs. Let $v \in \vertexset(G)$ be a vertex of $G$. The
\emph{(open) neighbourhood} of $v$, written $\neighbourhood_G(v)$, is the set of vertices adjacent
to $v$ not including $v$ itself, whilst the closed neighbourhood of $v$, written
$\neighbourhood_G[v]$, is the neighbourhood of $v$ plus $v$. The \emph{degree} of a vertex, $\degree_G(v)$,
is the cardinality of its open neighbourhood. The \emph{neighbourhood degree sequence} of a vertex
is the sequence consisting of the degrees of its neighbours, in descending order. Given a vertex set
$S \subseteq \vertexset(G)$, the subgraph \emph{induced by} $S$, written $G[S]$, is the subgraph of
$G$ with only the vertices in $S$ together with all the edges between them. A \emph{clique} is a
subgraph where every vertex is adjacent to every other in the subgraph.

\paragraph{Homomorphisms.} A \emph{homomorphism} from $G$ to $H$ is a function mapping vertices of
$G$ to vertices of $H$, such that adjacent vertices in $G$ are mapped to adjacent vertices in $H$. A
homomorphism $h$ is \emph{locally injective} if for every vertex $w$, the restriction of $h$ to
$G[N_G[w]]$ is injective; if $h$ is injective globally we call it a \emph{(non-induced) subgraph
isomorphism}.

?? loops, be really careful with this

\paragraph{Constraint programming.} ?? A constraint programming algorithm.

\paragraph{Degree-based invariants for homomorphisms.} The use of constraint programming techniques
for finding homomorphisms relies upon exploiting various invariants. It is straightforward to verify the following.

\begin{proposition}\label{proposition:degreends}
    Suppose  $i$ is a locally injective homomorphism from a $G$ to  $H$. Let
    $v$ be any vertex. Then:
    \begin{enumerate}
        \item $i$ cannot map $v$ to a vertex of lower degree, $\degree_G(v) \le \degree_H(i(v))$.
        \item Furthermore, $v$ cannot be mapped to any vertex whose neighbourhood degree sequence is
            not pointwise greater than or equal to its own
           .
    \end{enumerate}
\end{proposition}
Since subgraph isomorphisms are in particular locally injective, these also hold for subgraph isomorphisms \cite{DBLP:journals/constraints/ZampelliDS10}.
Every recent
constraint programming solver makes use of the of the above invariants for subgraph isomowphisms.
However, these invariants do \emph{not} hold for homomorphisms in general. As a simple counter-example, a
homomorphism may map a star graph (one central vertex of high degree, which is adjacent to many
other vertices, each of which has no other neighbours) onto a single edge.

The simplest way for a constraint programming algorithm to use these results is as unary
constraints, which are propagated when domains are initialised, before search begins. For each
domain representing a pattern vertex, any value representing target vertex whose degree or
neighbourhood degree sequence is too low may immediately be rejected.

\paragraph{Path-based invariants for homomorphisms.} Constraint programming solvers can also exploit
invariants that are based upon paths. This is done by automatically adding \emph{implied}
constraints to the problem that are implied by the original model, but that will give stronger
propagation power.

\begin{proposition}For the problem of finding a subgraph isomorphism $i$ from a graph $G$ to a graph
    $H$, the following constraints are implied for any pair of vertices $v, w \in \vertexset(G)$:
    \begin{enumerate}
        \item The distance between $v$ and $w$ is at least the distance between $i(v)$ and $i(w)$
            \cite{DBLP:conf/cp/AudemardLMGP14}.
        \item If there are at least $k$ simple
            paths of length exactly $\ell$ between $v$ and $w$, then there must be at least $k$
            simple paths of length exactly $\ell$ between $i(v)$ and $i(w)$
            \cite{DBLP:conf/cp/McCreeshP15}.
    \end{enumerate}
\end{proposition}

It is easy to verify that the first of these two properties is valid for \emph{any} homomorphism.
The second property does not hold for homomorphisms in general: for example, a pair of vertices
connected by three paths of length two may be mapped onto a pair of vertices connected by a single
path of length two. Local injectivity is trickier. The second property does not hold in full
generality, because, for example, a path of length three may be mapped onto a triangle whilst
respecting local injectivity. However, a weaker result holds:

\begin{proposition}For the problem of finding a locally injective graph homomorphism $i$ from a
    graph $G$ to a graph $H$, for any pair of vertices $v, w \in \vertexset(G)$, if there are at
    least $k$ simple paths of length exactly two between $v$ and $w$, then there must be at least
    $k$ simple paths of length exactly two between $i(v)$ and $i(w)$.
\end{proposition}

\begin{proof}Let $\{ x_1, \ldots, x_n \}$ be the intermediate vertices on the paths of length two
between $v$ and $w$. Observe that each $x_j$ is in the neighbourhood of $v$, and so must be mapped
    to different vertices. Thus each sequence $(i(v), i(x_i), i(w))$ gives a distinct simple path of
length two between $i(v)$ and $i(w)$ as required.\end{proof}

?? Corollary: $G^d$ graphs.

\paragraph{Cliques and homomorphisms.} Finally, we come to the main result of this paper. Observe
that until now, we have not seen any unary constraints which are valid for the general homomorphism
problem. All existing constraint programming approaches for the subgraph isomorphism problem begin
by branching on the variable which has the smallest domain---typically this will be a domain for a
pattern vertex of high degree, or which has many high degree neighbours. Furthermore, once one such
guessed assignment has been made, adjacency propagation means many other domains will be
substantially reduced in size, making subsequent branching choices simpler.  However, for
homomorphism problems, if we cannot find any implied unary constraints then every domain will
initially be of the same size, which will make it much harder for a solver to know where to start.
This motivates the following observation.

\begin{proposition}[Cliques are preserved]\label{proposition:clique}
    Let $i$ be a homomorphism from $G$ to $H$ where $H$ does
    not contain any loops. Let $S\subset V$ be such that $G[S]=K_k$. Then $H[i(S)]=K_k$. 
\end{proposition}

\begin{proof}
    Let $j$ and $k$ be two distinct vertices of the clique in $G$. By definition of a homomorphism,
    $i(j)$ and $i(k)$ must be adjacent. And, because $H$ does not contain loops, $i(j)$ cannot equal
    $i(k)$.
\end{proof}

\begin{corollary}\Cref{proposition:clique} holds for locally injective graph homomorphisms and for
    subgraph isomorphisms even if loops are present in the second graph.
\end{corollary}

We will discuss how this is useful in practice in the following section.

\section{Design and Implementation}

Having determined which commonly-used subgraph isomorphism invariants do and do not hold for other
forms of homomorphism, and having discovered a new clique-based invariant, we will now look at how
these invariants may be used in practice. Our starting point is the Glasgow Subgraph Solver
\cite{DBLP:conf/gg/McCreeshP020}, due to it being the current single strongest solver for the
subgraph isomorphism problem.

??

We implemented distance filtering for the basic homomorphism problem, using
the existing supplemental graphs framework that the solver uses for subgraph isomorphism to create
pseudo-adjacency constraints for vertices that are distance two away from each other; this was
routine.

We also implemented clique constraints, initially using the Glasgow Subgraph Solver's existing
maximum clique solver to perform domain filtering. Preliminary experiments showed that a na{\"\i}ve
approach, which begins by calculating the maximum clique size for the neighbourhood of each pattern
vertex and each target vertex, would add as much as three minutes of preprocessing time to some
problem instances which could otherwise be solved in a few seconds. We therefore use a more
intelligent approach, which we now describe.

\subsection{Optimising Maximum Clique Solver Calls}

We calculate the maximum clique size for the neighbourhood of a first pattern vertex $p_1$.  Having
found a maximum clique $\omega_1$ for a vertex $p$, for every other vertex $q \in \omega_1$, we
remember that the maximum clique for $q$'s neighbourhood has at least $|\omega_1|$ vertices. We then
proceed to find a maximum clique $\omega_2$ for a second pattern vertex $p_2$; however, if $p_2$ was
a member of $\omega_1$, we initialise the clique solver with a lower bound of $n$ rather than
starting from scratch. We then find the maximum clique size for a third pattern vertex $p_3$, using
whichever lower bound of $|\omega_1|$ and $|\omega_2|$ is better (if both are valid), and so on.

We then move on to the target vertices, using a similar caching routine. Rather than calculating a
clique size for every single target vertex, we only calculate a value for target vertices which are
present in at least one variable's domain, after other unary constraints have been applied.
(Depending upon the problem variant, implied constraints like degree and neighbourhood degree
sequence can eliminate some target vertices from the domains of all pattern variables.)
Additionally, we do not require the maximum clique solver to run to completion and guarantee that it
has found a maximum clique. Instead, we allow it to stop as soon as it has found a clique with as
many vertices as the largest pattern clique. This is useful in practice because it may be very hard
to decide whether a particular target vertex has neighbourhood clique size of, say, 15 or 16, but if
the largest pattern vertex has a neighbourhood clique size of only 5 then this is irrelevant.

?? Why this works

\subsection{Proof Logging}

?? How to log proofs

\section{Experiments}

\begin{figure*}[p]
    \,\hfill\begin{tabular}{c@{}c@{}c@{}}
    \includegraphics{gen-graph-cumulatives.pdf}
        &
    \includegraphics{gen-graph-cumulatives-differences.pdf}
        &
    \includegraphics{gen-graph-cumulatives-aggregate.pdf}
        \\[5mm]
    \includegraphics{gen-graph-cumulatives-hom.pdf}
        &
    \includegraphics{gen-graph-cumulatives-local.pdf}
        &
    \includegraphics{gen-graph-cumulatives-si.pdf}
    \end{tabular}\hfill\,

    \caption{On the top left, the cumulative number of instances solved over time for the three
    problem variants, with and without clique filtering, and with and without distance filtering for
    the homomorphism problem. The remaining plots re-display this data, as follows. The three plots
    on the bottom row zoom in on the cumulative number of instances solved, for the homomorphism
    problem on the left, the locally injective homomorphism problem in the centre, and the subgraph
    isomorphism problem on the right. The top centre plot shows the additional number of instances
    solved at any given time when using the new forms of filtering for all problem variants, and the
    top right plot shows the aggregate speedups from each form of filtering.}
\end{figure*}
\begin{figure*}[p]
    \,\hfill\begin{tabular}{c@{\hspace{4mm}}c@{\hspace{4mm}}c@{\hspace{4mm}}c@{\hspace{4mm}}}
        \includegraphics{gen-graph-scatter-hom-c.pdf}
        &
        \includegraphics{gen-graph-scatter-hom-cd.pdf}
        &
        \includegraphics{gen-graph-scatter-local.pdf}
        &
        \includegraphics{gen-graph-scatter-si.pdf}
    \end{tabular}\hfill\,

    \caption{Looking at the effects of additional filtering on an instance by instance basis, for
    homomorphism with just clique filtering and with both clique and distance filtering, and for the
    other two variants with clique filtering. Each point represents one instance, the vertical axis
    is the runtime with filtering in ms, and the horizontal axis is the runtime without filtering in
    ms (and so points below the diagonal are speedups). Points on the outer axes are timeouts. The
    different point styles show the different families of instance from the benchmark set, and
    illustrate that in each the filtering is broadly useful rather than being specific to a single
    kind of application.}
\end{figure*}

We now evaluate this approach empirically.

?? How good is it

?? Time on cliques

?? Whether cliques are hard

\section{Conclusion and Future Work}

?? Neighbourhood colourability? Cores?

\section*{Acknowledgements}

This work was supported by the Engineering and Physical Sciences Research Council [grant number
EP/P026842/1].

\bibliographystyle{named}
\bibliography{paper}

\end{document}

% vim: set tw=100 spell spelllang=en : %

\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in
\usepackage{ijcai21}
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algorithmic}
\urlstyle{same}

\usepackage{cleveref}
\crefname{figure}{figure}{figures}
\Crefname{figure}{Figure}{Figures}

\usepackage{tikz}
\usetikzlibrary{shapes}

% \usepackage{showframe}

\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}

\newcommand{\citet}[1]{\citeauthor{#1} \shortcite{#1}}

\usepackage{complexity}

\pdfinfo{
/TemplateVersion (IJCAI.2021.0)
}

\title{Solving Graph Homomorphism and Subgraph Isomorphism Problems Faster Through Clique Neighbourhood Constraints}

\author{
Ciaran McCreesh$^1$
\and
Sonja Kraiczy$^2$
\affiliations
$^1$University of Glasgow\\
$^2$University of Oxford\\
\emails
ciaran.mccreesh@glasgow.ac.uk
}

\newcommand{\neighbourhood}{\operatorname{N}}
\newcommand{\vertexset}{\operatorname{V}}
\newcommand{\degree}{\operatorname{deg}}
\newcommand{\nds}{\operatorname{S}}

\begin{document}

\maketitle

\begin{abstract}
    Graph homomorphism problems involve finding adjacency-preserving mappings between two graphs.
    Many of these problems are theoretically hard, but can be solved quite efficiently in practice
    through constraint programming techniques.  This paper adapts techniques from the
    state-of-the-art in subgraph isomorphism solving to broader graph homomorphism problems, and
    introduces a new form of filtering based upon clique-finding. We evaluate these techniques
    empirically, and show they are effective in practice for the locally injective graph
    homomorphism and subgraph isomorphism problems, as well as giving the first practical constraint
    programming approach to finding general graph homomorphisms.
\end{abstract}

\section{Introduction}

A \emph{graph homomorphism} is a function between two graphs that maps adjacent vertices to adjacent
vertices. An injective graph homomorphism is more commonly known as a \emph{subgraph isomorphism},
whilst a \emph{locally injective homomorphism} is one which is injective when restricted to any
individual vertex and its neighbourhood \cite{DBLP:journals/csr/FialaK08}. Finding any of these three kinds of homomorphism between
two given graphs is \NP-complete.  The subgraph isomorphism problem arises in many practical
applications, including ??, and as such there has been a lot of research into finding algorithms
which perform well empirically. Most approaches are based either upon very fast but simple
backtracking algorithms,
\cite{DBLP:journals/pami/CordellaFSV04,DBLP:journals/bmcbi/BonniciGPSF13,DBLP:conf/gbrpr/CarlettiFSV17}
which often but not always perform well on very easy instances, or upon constraint programming
algorithms
\cite{DBLP:journals/constraints/ZampelliDS10,DBLP:journals/ai/Solnon10,DBLP:conf/cp/AudemardLMGP14,DBLP:conf/cp/McCreeshP15,DBLP:conf/cpaior/ArchibaldDHMP019},
which have higher startup costs but that perform vastly better on harder instances and much more
consistently on easy instances \cite{DBLP:journals/jair/McCreeshPST18,DBLP:conf/gbrpr/Solnon19}. The
current state of the art is the Glasgow Subgraph Solver \cite{DBLP:conf/gg/McCreeshP020}, which is a
dedicated constraint programming solver for subgraph-finding problems. Much of its performance comes
from inference strategies based upon degrees and neighbourhood degree sequences
\cite{DBLP:journals/constraints/ZampelliDS10}, counting paths between vertices
\cite{DBLP:conf/cp/AudemardLMGP14,DBLP:conf/cp/McCreeshP15}, and cardinality reasoning
\cite{DBLP:journals/ai/Solnon10}, which can be used to eliminate many infeasible candidate
assignments without search.

One might hope that this inference would also be helpful for other graph homomorphism problem
variants. Indeed, this paper proves that many, but not all, of these strategies are also valid in
the locally injective case, and that simple distance filtering is valid for all homomorphisms.
However, we also show that \emph{none} of the other strategies are valid for finding homomorphisms
where there is no injectivity requirement. Finally, we introduce a new filtering technique that is
based upon finding a maximum clique in the neighbourhood of each pattern vertex, and prove that this
technique is valid even in the general case. Although this new filtering technique involves solving
many additional \NP-complete problems as a preprocessing step, we demonstrate that it is effective
in practice, particularly for the non-injective problem where filtering allows a constraint
programming algorithm to solve instances over eight hundred times faster in aggregate, over a
collection of over fourteen thousand standard benchmark instances. This shows, for the first time,
that modern constraint programming techniques can be practical for less constrained graph
homomorphism finding problems; previous algorithmic approaches have focused instead upon worst-case
computational bounds
\cite{DBLP:journals/csr/FialaK08,DBLP:journals/ipl/Rzazewski14,DBLP:journals/tcs/ChaplickFHPT15},
whose practical utility has yet to be demonstrated. The empirical effectiveness of our results is
especially important because many current applications use subgraph isomorphism solvers only because
they perform well using off the shelf solvers, rather than because they exactly match ideal domain
requirements ??cite.

\section{Background and Theory}

We begin by introducing notation and terminology, and by giving the theoretical results which
support our implementation.

\paragraph{Graphs.} Let $G$ and $H$ be graphs. Let $v \in \vertexset(G)$ be a vertex of $G$. The
\emph{(open) neighbourhood} of $v$, written $\neighbourhood_G(v)$, is the set of vertices adjacent
to $v$ not including $v$ itself, whilst the closed neighbourhood of $v$, written
$\neighbourhood_G[v]$, is the neighbourhood of $v$ plus $v$. The \emph{degree} of a vertex, $\degree_G(v)$,
is the cardinality of its open neighbourhood. The \emph{neighbourhood degree sequence} of a vertex
is the sequence consisting of the degrees of its neighbours, in descending order. Given a vertex set
$S \subseteq \vertexset(G)$, the subgraph \emph{induced by} $S$, written $G[S]$, is the subgraph of
$G$ with only the vertices in $S$ together with all the edges between them. A \emph{clique} is a
subgraph where every vertex is adjacent to every other in the subgraph.

\paragraph{Homomorphisms.} A \emph{homomorphism} from $G$ to $H$ is a function mapping vertices of
$G$ to vertices of $H$, such that adjacent vertices in $G$ are mapped to adjacent vertices in $H$. A
homomorphism $h$ is \emph{locally injective} if for every vertex $w$, the restriction of $h$ to
$G[N_G[w]]$ is injective; if $h$ is injective globally we call it a \emph{(non-induced) subgraph
isomorphism}.

\paragraph{Loops.} A vertex which is adjacent to itself is called a \emph{loop}. By a careful reading
of the definition, any homomorphism must map loops onto loops---and indeed, the Glasgow Subgraph
Solver and this paper take this approach (although some other algorithm implementations do not). It
therefore follows that for the homomorphism \emph{decision} problem where there are no injectivity
constraints, any problem instance which has a loop in the codomain graph is trivially satisfiable,
although the \emph{counting} problem remains \#\P-hard \cite{DBLP:journals/rsa/DyerG00}.

\paragraph{Constraint programming.} A \emph{constraint satisfaction problem} is defined in terms of
a set of \emph{variables}, each of which has a \emph{domain} of possible \emph{values}, together
with a set of constraints; the goal is to give each variable a value from its domain, whilst
satisfying all of the constraints. Homomorphism problems have a natural representation as a
constraint satisfaction problem: we have a variable for each vertex in the domain graph, whose
values range over the codomain graph, and a set of constraints saying that adjacent vertices must be
mapped to adjacent vertices. For the injective variants, one or more \emph{all-different}
constraints are also present. A typical constraint programming approach to solving such a problem is
to combine inference through constraint propagation with an intelligent backtracking search.

\paragraph{Degree-based invariants for homomorphisms.} Constraint programming techniques for finding
homomorphisms can be made much more effective by exploiting certain invariants. It is
straightforward to verify the following.

\begin{proposition}[neighbourhood degree sequences are preserved]\label{proposition:degreends}
    Suppose  $i$ is a locally injective homomorphism from a $G$ to  $H$. Let
    $v$ be any vertex. Then:
    \begin{enumerate}
        \item $i$ cannot map $v$ to a vertex of lower degree, $\degree_G(v) \le \degree_H(i(v))$.
        \item Furthermore, $v$ cannot be mapped to any vertex whose neighbourhood degree sequence is
            not pointwise greater than or equal to its own.
    \end{enumerate}
\end{proposition}
Since subgraph isomorphisms are in particular locally injective, these invariants also hold for
subgraph isomorphisms \cite{DBLP:journals/constraints/ZampelliDS10}; indeed, every recent constraint
programming approach for subgraph isomorphism finding make use of degrees and neighbourhood degree
sequences. The simplest way for a constraint programming algorithm to use these results is as unary
constraints, which are propagated when domains are initialised, before search begins. For each
domain representing a pattern vertex, any value representing a target vertex whose degree or
neighbourhood degree sequence is too low may immediately be rejected.

\begin{figure}
    \hfill\,\begin{minipage}{3cm}
    \begin{tikzpicture}
        \node [draw, fill, circle, inner sep=1.5pt] (A1) at (0, 0) {};
        \node [draw, circle, inner sep=1.5pt] (A2) at (0:0.3) {};
        \node [draw, circle, inner sep=1.5pt] (A3) at (60:0.3) {};
        \node [draw, circle, inner sep=1.5pt] (A4) at (120:0.3) {};
        \node [draw, circle, inner sep=1.5pt] (A5) at (180:0.3) {};
        \node [draw, circle, inner sep=1.5pt] (A6) at (240:0.3) {};
        \node [draw, circle, inner sep=1.5pt] (A7) at (300:0.3) {};

        \draw (A1) -- (A2);
        \draw (A1) -- (A3);
        \draw (A1) -- (A4);
        \draw (A1) -- (A5);
        \draw (A1) -- (A6);
        \draw (A1) -- (A7);

        \draw [->] (0.7, 0) -- (1.1, 0);

        \draw (1.5, 0) node [draw, fill, circle, inner sep=1.5pt] (B1) at ++ (90:0.15) {};
        \draw (1.5, 0) node [draw, circle, inner sep=1.5pt] (B2) at ++ (270:0.15) {};
        \draw (B1) -- (B2);
    \end{tikzpicture}\end{minipage}\hfill\begin{minipage}{3cm}
    \begin{tikzpicture}
        \node [draw, fill, circle, inner sep=1.5pt] (A1) at (0, 0) {};
        \node [draw, inner sep=1.5pt] (A2) at (0.3, 0) {};
        \node [draw, inner sep=1.5pt] (A3) at (0.3, -0.2) {};
        \node [draw, inner sep=1.5pt] (A4) at (0.3, 0.2) {};
        \node [draw, circle, inner sep=1.5pt] (A5) at (0.6, 0) {};

        \draw (A1) -- (A2);
        \draw (A1) -- (A3);
        \draw (A1) -- (A4);
        \draw (A2) -- (A5);
        \draw (A3) -- (A5);
        \draw (A4) -- (A5);

        \draw [->] (1.0, 0) -- (1.4, 0);

        \node [draw, fill, circle, inner sep=1.5pt] (B1) at (1.8, 0) {};
        \node [draw, inner sep=1.5pt] (B2) at (2.1, 0) {};
        \node [draw, circle, inner sep=1.5pt] (B5) at (2.4, 0) {};

        \draw (B1) -- (B2);
        \draw (B2) -- (B5);
    \end{tikzpicture}\end{minipage}\hfill\,

    \bigskip

    \,\hfill\begin{minipage}{3cm}
    \begin{tikzpicture}
        \node [draw, fill, circle, inner sep=1.5pt] (A1) at (0, 0) {};
        \node [draw, circle, inner sep=1.5pt] (A2) at (0.3, 0) {};
        \node [draw, inner sep=1.5pt] (A3) at (0.6, 0) {};
        \node [draw, fill, circle, inner sep=1.5pt] (A4) at (0.9, 0) {};

        \draw (A1) -- (A2);
        \draw (A2) -- (A3);
        \draw (A3) -- (A4);

        \draw [->] (1.3, 0) -- (1.7, 0);

        \draw (2.2, 0) node [draw, fill, circle, inner sep=1.5pt] (B1) at ++ (120:0.3) {};
        \draw (2.2, 0) node [draw, circle, inner sep=1.5pt] (B2) at ++ (240:0.3) {};
        \draw (2.2, 0) node [draw, inner sep=1.5pt] (B3) at ++ (0:0.3) {};

        \draw (B1) -- (B2);
        \draw (B2) -- (B3);
        \draw (B3) -- (B1);
    \end{tikzpicture}\end{minipage}\hfill\begin{minipage}{3cm}
        \begin{tikzpicture}
        \node [draw, fill, circle, inner sep=1.5pt] (A1) at (0, 0) {};
        \node [draw, inner sep=1.5pt] (A2) at (0.3, -0.2) {};
        \node [draw, fill, inner sep=1.5pt] (A3) at (0.3, 0.2) {};
        \node [draw, circle, inner sep=1.5pt] (A4) at (0.6, 0) {};
        \node [draw, diamond, fill, inner sep=1.5pt] (A5) at (0.9, -0.2) {};
        \node [draw, diamond, inner sep=1.5pt] (A6) at (0.9, 0.2) {};
        \node [draw, fill, circle, inner sep=1.5pt] (A7) at (1.2, 0) {};

        \draw (A1) -- (A2);
        \draw (A1) -- (A3);
        \draw (A2) -- (A4);
        \draw (A3) -- (A4);
        \draw (A4) -- (A5);
        \draw (A4) -- (A6);
        \draw (A5) -- (A7);
        \draw (A6) -- (A7);

        \draw [->] (1.4, 0) -- (1.7, 0);

        \node [draw, fill, circle, inner sep=1.5pt] (B1) at (2, 0) {};
        \node [draw, fill, inner sep=1.5pt] (B2) at (2.3, -0.15) {};
        \node [draw, diamond, inner sep=1.5pt] (B3) at (2.3, 0.15) {};
        \node [draw, diamond, fill, inner sep=1.5pt] (B4) at (2.3, -0.45) {};
        \node [draw, inner sep=1.5pt] (B5) at (2.3, 0.45) {};
        \node [draw, circle, inner sep=1.5pt] (B6) at (2.6, 0) {};

        \draw (B1) -- (B2);
        \draw (B1) -- (B3);
        \draw (B1) -- (B4);
        \draw (B1) -- (B5);
        \draw (B6) -- (B2);
        \draw (B6) -- (B3);
        \draw (B6) -- (B4);
        \draw (B6) -- (B5);
    \end{tikzpicture}\end{minipage}\hfill\,

    \caption{Counter-examples for various properties which are not invariants. The different shapes
        for vertices show a mapping, with vertices being mapped to vertices of the same shape. The
        top left example shows that degree is not preserved in a homomorphism; the top right that path
        counts are not preserved in a homomorphism; the bottom left that path counts of length three
        are not preserved in a locally injective homomorphism; and the bottom right that a locally
        injective homomorphism $i$ can give rise to a homomorphism $i^{2,2}$ which is not locally
        injective.} \label{figure:counterexamples}
\end{figure}

However, these invariants do \emph{not} hold for homomorphisms in general. As a simple
counter-example, a homomorphism may map a star graph onto a single edge, as in
\cref{figure:counterexamples} (top left).

\paragraph{Path-based invariants for homomorphisms.} Constraint programming solvers can also exploit
invariants that are based upon paths. This is done by automatically adding \emph{implied}
constraints to the problem that are implied by the original model, but that will give stronger
propagation power.

\begin{proposition}[paths are preserved by subgraph isomorphisms]\label{proposition:distances}For
    the problem of finding a subgraph isomorphism $i$ from a graph $G$ to a graph $H$, the following
    constraints are implied for any pair of vertices $v, w \in \vertexset(G)$:
    \begin{enumerate}
        \item The distance between $v$ and $w$ is at least the distance between $i(v)$ and $i(w)$
            \cite{DBLP:conf/cp/AudemardLMGP14}.
        \item If there are at least $k$ simple
            paths of length exactly $\ell$ between $v$ and $w$, then there must be at least $k$
            simple paths of length exactly $\ell$ between $i(v)$ and $i(w)$
            \cite{DBLP:conf/cp/McCreeshP15}.
    \end{enumerate}
\end{proposition}

It is easy to verify that the first of these two properties is valid for \emph{any} homomorphism.
The second property does not hold for homomorphisms in general: for example, a pair of vertices
connected by three paths of length two may be mapped onto a pair of vertices connected by a single
path of length two (see \cref{figure:counterexamples}, top right). Local injectivity is trickier.
The second property does not hold in full generality, because, for example, a path of length three
may be mapped onto a triangle whilst respecting local injectivity (\cref{figure:counterexamples},
bottom left).  However, we observe that a weaker result holds:

\begin{proposition}[paths of length two are preserved by locally injective
    homomorphisms]\label{proposition:paths}For the problem of finding a locally injective graph
    homomorphism $i$ from a graph $G$ to a graph $H$, for any pair of vertices $v, w \in
    \vertexset(G)$, if there are at least $k$ simple paths of length exactly two between $v$ and
    $w$, then there must be at least $k$ simple paths of length exactly two between $i(v)$ and
    $i(w)$.
\end{proposition}

\begin{proof}Let $\{ x_1, \ldots, x_n \}$ be the intermediate vertices on the paths of length two
between $v$ and $w$. Observe that each $x_j$ is in the neighbourhood of $v$, and so must be mapped
    to different vertices. Thus each sequence $(i(v), i(x_j), i(w))$ gives a distinct simple path of
length two between $i(v)$ and $i(w)$ as required.\end{proof}

Rather than using distance properties directly, \citet{DBLP:conf/cp/McCreeshP15} introduced
the notion of \emph{supplemental} graphs, with the idea that a constraint programming algorithm can
search for a mapping which is simultaneously a subgraph isomorphism between several different pairs
of graphs. Let $G^d$ be the graph with the same set of vertices as $G$, but an edge between vertices
$v$ and $w$ if the distance between $v$ and $w$ in $G$ is at most $d$.  Similarly, let $G^{n,\ell}$
be the graph with the same set of vertices as $G$, but an edge between vertices $v$ and $w$ if there
are at least $n$ simple paths of length exactly $\ell$ between $v$ and $w$ in $G$. Following on from
\cref{proposition:distances,proposition:paths}, we generalise the result of
\citeauthor{DBLP:conf/cp/McCreeshP15} as follows.

\begin{corollary}Any homomorphism $i$ from $G$ to $H$ gives a homomorphism $i^d$ from $G^d$ to $H^d$
    defined by $i^d(v) = i(v)$, for all $d$. Furthermore, if $i$ is locally injective, then for all
    $n$, there is a homomorphism $i^{n,2}$ from $G^{n,2}$ to
    $H^{n,2}$ defined by $i^{n,2}(v) = i(v)$.
\end{corollary}

Note carefully that $i^{n,2}$ is \emph{not} necessarily locally injective, even if $i$ is; we
illustrate a counter-example in \cref{figure:counterexamples} (bottom right). This is in contrast to
subgraph isomorphism, where $i^{n,\ell}$ is a subgraph isomorphism for all $\ell$
\cite{DBLP:conf/cp/McCreeshP15}.

\paragraph{Cliques and homomorphisms.} Finally, we come to the main result of this paper. Observe
that until now, we have not seen any unary constraints which are valid for the general homomorphism
problem. All existing constraint programming approaches for the subgraph isomorphism problem begin
by branching on the variable which has the smallest domain---typically this will be a domain for a
pattern vertex of high degree, or which has many high degree neighbours. Furthermore, once one such
guessed assignment has been made, adjacency propagation means many other domains will be
substantially reduced in size, making subsequent branching choices simpler.  However, for
homomorphism problems, if we cannot find any implied unary constraints then every domain will
initially be of the same size, which will make it much harder for a solver to know where to start.
This motivates the following observation.

\begin{proposition}[Cliques are preserved]\label{proposition:clique}
    Let $i$ be a homomorphism from $G$ to $H$ where $H$ does
    not contain any loops. Let $S\subset V$ be such that $G[S]$ is a $k$-vertex clique. Then
    $H[i(S)]$ is also a $k$-vertex clique.
\end{proposition}

\begin{proof}
    Let $j$ and $k$ be two distinct vertices of the clique in $G$. By definition of a homomorphism,
    $i(j)$ and $i(k)$ must be adjacent. And, because $H$ does not contain loops, $i(j)$ cannot equal
    $i(k)$.
\end{proof}

\begin{corollary}\Cref{proposition:clique} holds for locally injective graph homomorphisms and for
    subgraph isomorphisms even if loops are present in the second graph.
\end{corollary}

We will discuss how this is useful in practice in the following section.

\section{Design and Implementation}

Having determined which commonly-used subgraph isomorphism invariants do and do not hold for other
forms of homomorphism, and having discovered a new clique-based invariant, we will now look at how
these invariants may be used in practice. Our starting point is the Glasgow Subgraph Solver
\cite{DBLP:conf/gg/McCreeshP020}, due to it being the current single strongest solver for the
subgraph isomorphism problem.

??

We implemented distance filtering for the basic homomorphism problem, using
the existing supplemental graphs framework that the solver uses for subgraph isomorphism to create
pseudo-adjacency constraints for vertices that are distance two away from each other; this was
routine.

We also implemented clique constraints, initially using the Glasgow Subgraph Solver's existing
maximum clique solver to perform domain filtering. Preliminary experiments showed that a na{\"\i}ve
approach, which begins by calculating the maximum clique size for the neighbourhood of each pattern
vertex and each target vertex, would add as much as three minutes of preprocessing time to some
problem instances which could otherwise be solved in a few seconds. We therefore use a more
intelligent approach, which we now describe.

\subsection{Optimising Maximum Clique Solver Calls}

We calculate the maximum clique size for the neighbourhood of a first pattern vertex $p_1$.  Having
found a maximum clique $\omega_1$ for a vertex $p$, for every other vertex $q \in \omega_1$, we
remember that the maximum clique for $q$'s neighbourhood has at least $|\omega_1|$ vertices. We then
proceed to find a maximum clique $\omega_2$ for a second pattern vertex $p_2$; however, if $p_2$ was
a member of $\omega_1$, we initialise the clique solver with a lower bound of $n$ rather than
starting from scratch. We then find the maximum clique size for a third pattern vertex $p_3$, using
whichever lower bound of $|\omega_1|$ and $|\omega_2|$ is better (if both are valid), and so on.

We then move on to the target vertices, using a similar caching routine. Rather than calculating a
clique size for every single target vertex, we only calculate a value for target vertices which are
present in at least one variable's domain, after other unary constraints have been applied.
(Depending upon the problem variant, implied constraints like degree and neighbourhood degree
sequence can eliminate some target vertices from the domains of all pattern variables.)
Additionally, we do not require the maximum clique solver to run to completion and guarantee that it
has found a maximum clique. Instead, we allow it to stop as soon as it has found a clique with as
many vertices as the largest pattern clique. This is useful in practice because it may be very hard
to decide whether a particular target vertex has neighbourhood clique size of, say, 15 or 16, but if
the largest pattern vertex has a neighbourhood clique size of only 5 then this is irrelevant.

?? Why this works

\subsection{Proof Logging}

?? How to log proofs

\section{Experiments}

\begin{figure*}[p]
    \,\hfill\begin{tabular}{c@{}c@{}c@{}}
    \includegraphics{gen-graph-cumulatives.pdf}
        &
    \includegraphics{gen-graph-cumulatives-differences.pdf}
        &
    \includegraphics{gen-graph-cumulatives-aggregate.pdf}
        \\[5mm]
    \includegraphics{gen-graph-cumulatives-hom.pdf}
        &
    \includegraphics{gen-graph-cumulatives-local.pdf}
        &
    \includegraphics{gen-graph-cumulatives-si.pdf}
    \end{tabular}\hfill\,

    \caption{On the top left, the cumulative number of instances solved over time for the three
    problem variants, with and without clique filtering, and with and without distance filtering for
    the homomorphism problem. The remaining plots re-display this data, as follows. The three plots
    on the bottom row zoom in on the cumulative number of instances solved, for the homomorphism
    problem on the left, the locally injective homomorphism problem in the centre, and the subgraph
    isomorphism problem on the right. The top centre plot shows the additional number of instances
    solved at any given time when using the new forms of filtering for all problem variants, and the
    top right plot shows the aggregate speedups from each form of filtering.}
\end{figure*}
\begin{figure*}[p]
    \,\hfill\begin{tabular}{c@{\hspace{4mm}}c@{\hspace{4mm}}c@{\hspace{4mm}}c@{\hspace{4mm}}}
        \includegraphics{gen-graph-scatter-hom-c.pdf}
        &
        \includegraphics{gen-graph-scatter-hom-cd.pdf}
        &
        \includegraphics{gen-graph-scatter-local.pdf}
        &
        \includegraphics{gen-graph-scatter-si.pdf}
    \end{tabular}\hfill\,

    \caption{Looking at the effects of additional filtering on an instance by instance basis, for
    homomorphism with just clique filtering and with both clique and distance filtering, and for the
    other two variants with clique filtering. Each point represents one instance, the vertical axis
    is the runtime with filtering in ms, and the horizontal axis is the runtime without filtering in
    ms (and so points below the diagonal are speedups). Points on the outer axes are timeouts. The
    different point styles show the different families of instance from the benchmark set, and
    illustrate that in each the filtering is broadly useful rather than being specific to a single
    kind of application.}
\end{figure*}

We now evaluate this approach empirically.

?? How good is it

?? Time on cliques

?? Whether cliques are hard

\section{Conclusion and Future Work}

?? Neighbourhood colourability? Cores?

?? Epimorphism

\section*{Acknowledgements}

This work was supported by the Engineering and Physical Sciences Research Council [grant number
EP/P026842/1].

\bibliographystyle{named}
\bibliography{paper}

\end{document}

% vim: set tw=100 spell spelllang=en : %
